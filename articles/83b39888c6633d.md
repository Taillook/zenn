---
title: "axumã§redis-rsã®pubsubã‚’ä½¿ã†æ™‚ã®çŸ¥è¦‹"
emoji: "ğŸ¦€"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["rust", "axum", "redis"]
published: true
---
æœ€è¿‘axumã®ä¸Šã§redisã‚’ä½¿ãŠã†ã¨æ€ã£ã¦å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚
ã“ã“ã§ã¯çŸ¥è¦‹ã«ãªã‚Šãã†ãªtipsã ã£ãŸã‚Šã‚’ç´¹ä»‹ã—ã¾ã™ã€‚

## library
axumã¨redis-rsã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¯ä»¥ä¸‹ã®æŒ‡å®šã‚’ã—ã¦ã„ã¾ã™ã€‚
```toml
redis = { version = "0.21.5", features = ["tokio-comp"] }
axum = { version = "0.4.0", features = ["headers"] }
```

## subscribeã®æ–¹æ³•

axumã®Extensionã«ä»¥ä¸‹ã®ã‚ˆã†ãªstateã‚’å…¥ã‚Œã¾ã™ã€‚
```rust
pub struct AppState {
    rc: redis::Client,
}
```

s_taskã¨rc_taskã®2ã¤ã®`JoinHandle<()>`ã‚’ä½œã‚Šã€axumã‚µãƒ¼ãƒã¨redisã®subscriberã‚’`tokio::select!`ã§åŒæ™‚ã«å®Ÿè¡Œã•ã›ã¾ã™ã€‚
`subscribe_conn.psubscribe("*")`ã®éƒ¨åˆ†ã¯é€šå¸¸`subscribe`é–¢æ•°ã§subscribeã—ã¾ã™ãŒ`psubscribe`ã§[ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒ](https://redis.io/docs/manual/pubsub/#:~:text=5%0Afirst%0A%3A0-,Pattern,-%2Dmatching%20subscriptions)ã‚’ä½¿ã†ã“ã¨ã‚‚ã§ãã¾ã™ã€‚
```rust
    let mut s_task = {
        let app = app(app_state.clone());
        tokio::spawn(async move {
            if let Err(e) = axum::Server::bind(&addr)
                .serve(app.into_make_service())
                .await
            {
                panic!("{:?}", e)
            }
        })
    };
    let mut rc_task = {
        tokio::spawn(async move {
            let mut subscribe_conn = match app_state.rc.get_async_connection().await {
                Ok(sub) => sub.into_pubsub(),
                Err(e) => panic!("{:?}", e),
            };
            let mut subscribe_stream = match subscribe_conn.psubscribe("*").await {
                Ok(_) => subscribe_conn.on_message(),
                Err(e) => panic!("{:?}", e),
            };
    
            while let Some(sub) = subscribe_stream.next().await {
                let mut chennel_list = app_state.chennel_list.lock().await;
                let converted: String = match sub.get_payload::<String>() {
                    Ok(msg) => msg,
                    Err(e) => e.to_string(),
                };
                println!("{:?}", converted)
            }
        })
    };

    tokio::select! {
        _ = (&mut rc_task) => s_task.abort(),
        _ = (&mut s_task) => rc_task.abort(),
    }
```

## publishã®å‹å‘¨ã‚Šã®æ‰±ã„
ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã®å ´åˆ`result`å¤‰æ•°ã®å‹ãŒ`Result<{unknown}, RedisError>`ã¨ãªã‚Šã€``error[E0698]: type inside `async fn` body must be known in this context``ã¨ã„ã†ã‚¨ãƒ©ãƒ¼ã§ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ã«ãªã‚Šã¾ã™ã€‚
ã“ã®ãŸã‚ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«å‹ã‚’æ˜ç¤ºã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
```rust
use std::sync::Arc;

use axum::{extract::Extension, http::StatusCode, response::IntoResponse, Json};
use serde_json::json;
use redis::{AsyncCommands, RedisResult, Value, aio::Connection};

#[derive(Clone, Debug, PartialEq, Default, Serialize, Deserialize)]
pub struct PostHogeRequest {
    #[serde(rename = "channelId")]
    pub channel_id: String,
    #[serde(rename = "payload")]
    pub payload: ::std::collections::HashMap<String, serde_json::Value>,
}

pub async fn post_hoge(
    Json(params): Json<PostHogeRequest>,
    Extension(state): Extension<Arc<super::super::AppState>>,
) -> impl IntoResponse {
    let mut publish_conn:Connection = match state.rc.get_async_connection().await {
        Ok(c) => c,
        Err(e) => panic!("{:?}", e),
    };
    let result = publish_conn.publish(&params.channel_id, json!(params.payload).to_string()).await;

    match result {
        Ok(a) => StatusCode::NO_CONTENT.into_response(),
        Err(e) => (StatusCode::GONE, format!("{:?}", e)).into_response(),
    }
}
```
ä»¥ä¸‹ã®ã‚ˆã†ã«`result`å¤‰æ•°ã®å‹ã‚’`RedisResult<Value>`ã§æ˜ç¤ºã™ã‚‹ã¨ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚
`RedisResult<Value>`ã®ä¸­èº«ã¯`pub type RedisResult<T> = Result<T, RedisError>`ã§å®šç¾©ã•ã‚Œã¦ã„ã¦ã€`publish`ãŒè¿”ã™`Result<T, RedisError>`ã®Tã®ä¸­èº«ã¯`i64`ã§å®Ÿä½“ã¯`Value`ã¨ã„ã†enumã®ä¸€éƒ¨ã«å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚
```rust
let result: RedisResult<Value> = publish_conn.publish(&params.channel_id, json!(params.payload).to_string()).await;
```
